#!/usr/bin/python

'''
A simple announce-only IRC bot, used to display system status messages on IRC.
Maintains a TCP listener on localhost, latter invocations will use the same
connection to the IRC server.
'''

def usage():
    sys.stderr.write(
    '''A simple announce-only IRC bot, used to display system status messages on IRC.
Maintains a TCP listener on localhost, latter invocations will use the same
    connection to the IRC server.
    -h --help        usage
    -i --identity=x  use identity x from the config file,
                     defaults to *, the hostname
    -c --conf=x      read configuration file x
    -n --nodaemon    don't daemonize
    -v --verbose     dump network and protocol traffic
    -s --single      single shot run, exit after sending message
    -q --quit        tell the currently running daemon to quit
    <channel> <message>
''')

'''
purposely using the socket library directly and no networking frameworks for 
maximum portablity, just python and python's standard libary
'''

import os
import sys
import socket
import select
import time
import string
import re
import random
import posix
import pwd
import ConfigParser
import getopt
import resource

try:
    import ssl
except ImportError:
    # create a minimal ssl class that does the wrapping
    class ssl:
        def fileno(self):
            return self.origsock.fileno()
        def send(self, output):
            return self.sslsock.write(output)
        def recv(self, insize):
            return self.sslsock.read(insize)
        def __init__(self, sock):
            self.origsock = sock
            self.sslsock = socket.ssl(sock)
        @staticmethod
        def wrap_socket(sock):
            return ssl(sock)

class EndOfInput: pass
class TimeOut: pass

def ifverbose(m):
    global verbose
    if verbose:
        sys.stderr.write(str(m))
        sys.stderr.write("\n")

"""
Internal protocol between a running nodebot (primary) and new
instances (dependent):
 - each command is delimited by a newline
 - the known commands are:

    "-quit\n"
        force the persistent nodebot to quit
        anything sent to the persistent nodebot after the -quit command
        will be dropped

    "#chan string\n"
        announce string on IRC channel #chan. the channel name and the
        message are delimited by a run of whitespace

Don't want to accept raw IRC commands so the input can be sanity checked and
potentially be validated.
"""

def process_dependent(sock):
    global pendingoutput
    global running
    global upstreamdata
    try:
        input = sock.recv(1024)
        if len(input) == 0:
            raise EndOfInput
    except (socket.error, EndOfInput):
        ifverbose("!! disconnecting dependent")
        readsockets.pop(readsockets.index(sock))
        sock.shutdown(socket.SHUT_RDWR)
        input = ''
        try:
            del pendingoutput[sock]
        except KeyError:
            pass

    input = fix_shortline(sock, input)

    for line in input.splitlines():
        ifverbose("<+ %s" % (repr(line),))
        if line == "-quit":
            ifverbose("!! received quit")
            running = False
            return
        mo = re.match(r'^#(\w+)\s+(.+)?$', line)
        if mo:
            channel, msg = mo.groups()
            upstreamdata.append( (channel, msg) )

#shortline_stdin = ''
def process_stdin(r):
    global running
    global upstreamdata
    # global shortline_stdin
    try:
        # FIXME read blocks -- this is only a problem when we're the primary
        # and reading from stdin.
        input = r.read(10)
        if len(input) == 0:
            raise EndOfInput
    except (socket.error, EndOfInput):
        ifverbose("closing stdin")
        readsockets.pop(readsockets.index(r))
        r.close()
        running = False
        input = ''

    input = fix_shortline(r, input)

    for line in input.splitlines():
        ifverbose("<+ %s" % (repr(line),))
        upstreamdata.append( (arg_channel, line) )

def queue_output(sock, msg, pos=-1):
    try:
        if pos != -1:
            pendingoutput[sock].insert(pos, msg)
        else:
            pendingoutput[sock].append(msg)
    except (KeyError, IndexError):
        pendingoutput[sock] = [msg]

def parsemsg(s):
    """Breaks a message from an IRC server into its prefix, command, and 
       arguments.  Lifted from twisted, found on stackoverflow.  """
    prefix = ''
    trailing = []
    if not s:
        return ['', '', '']
    if s[0] == ':':
        prefix, s = s[1:].split(' ', 1)
    if s.find(' :') != -1:
        s, trailing = s.split(' :', 1)
        args = s.split()
        args.append(trailing)
    else:
        args = s.split()
    command = args.pop(0)
    return prefix, command, args

shortlines = {}
def fix_shortline(sock, s, maxsize=500):
    global shortlines
    try:
        s = shortlines[sock] + s
        del shortlines[sock]
    except KeyError:
        pass

    if len(s) >= maxsize:
        shortlines[sock] = s[500:]
        s = s[0:500]
        return s

    lastnl = s.rfind("\n")
    if lastnl >= 0:
        # only do the string manipulation if we have multiple lines
        # rather than trying to keep appending old data and the
        # input getting longer
        if s[-1:] != "\n":
            shortlines[sock] = s[lastnl+1:]
            s = s[:lastnl]
    else:
        shortlines[sock] = s
        s = ''
    return s
        

#shortline_irc = ''
def process_irccon(sock):
    global upstreamsock
    global registered
    global running
    global nick
    global preferred_nick
    #global shortline_irc

    try:
        input = sock.recv(1024)
        if len(input) == 0:
            raise EndOfInput
    except (socket.error, EndOfInput):
        running = False
        input = ''

    input = fix_shortline(sock, input)

    for line in input.splitlines():
        ifverbose("<< %s" % (line, ))
        prefix, command, args = parsemsg(line)

        if command == "ERROR":
            sys.stderr.write((" ".join(args)) + "\n")
            sys.exit(1)

        if command == "PING":
            queue_output(sock, "PONG :" + args[0] + "\r\n", 0)

        if command == "MODE":
            # this seems to be a good indication that we're registered
            ifverbose("!! now registered")
            registered = True

        if command == "401":
            # channel doesn't exist, nothing to do, really
            pass
            
        if command == "433" or command == "432":
            n = gen_nick()
            queue_output(sock, "NICK " + n + "\r\n", 0)

        if command == "NICK" or command == "004":
            # server has told us our nick
            nick = args[0]

        if command == "PRIVMSG" and (args[0] == nick or args[0] == preferred_nick):
            if prefix.index("!"):
                who = prefix[:prefix.index("!")]
                if args[1] == "config":
                    dump_config(who)
                if args[1] == "quit":
                    queue_output(upstreamsock, "PRIVMSG %s :quitting\r\n" % (who,))
                    running = False


def dump_config(touser):
    global options
    global upstreamsock
    c = 0
    for k,v in options.items():
        c = c + 1
        queue_output(upstreamsock, "PRIVMSG %s :%s : %s\r\n" % (touser, repr(k), repr(v)))
    queue_output(upstreamsock, "PRIVMSG %s : %d total items\r\n" % (touser, c))

def gen_nick():
    n = preferred_nick + '-' + hex(random.randint(1, 2 ** 16))[2:].upper().zfill(4)
    return n

def daemonize(skipfd):
    # skipfd allows us to skip over the socket we've opened up for listening
    os.fork() and sys.exit(0)
    maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if (maxfd == resource.RLIM_INFINITY):
        maxfd = 1024
    for fd in range(0, maxfd):
        if fd == skipfd:
            continue
        try:
            os.close(fd)
        except OSError:
            pass
    null = getattr(os, 'devnull', '/dev/null')
    os.open(null, os.O_RDWR)
    os.dup2(0, 1)
    os.dup2(0, 2)
    os.setsid()
    os.fork() and sys.exit(0)
    os.chdir('/')
    os.umask(0)


def drop_privs():
    if os.getuid() == 0:
        try:
            nobody_pw = pwd.getpwnam('nobody')
            nobody_uid, nobody_gid = nobody_pw.pw_uid, nobody_pw.pw_gid
        except KeyError:
            nobody_uid, nobody_gid = 65534, 65534
        os.setgid(nobody_gid)
        os.setuid(nobody_uid)


if __name__ == '__main__':

    drop_privs()

    try:
        optstr = "svnqhi:c:"
        optlist = ['single', 'verbose', 'nodeamon', 'quit', 'help', 
                   'identity=', 'conf=']
        opts, argv = getopt.getopt(sys.argv[1:], optstr, optlist)
    except getopt.GetoptError, err:
        sys.stderr.write(str(err)+"\n")
        usage()
        sys.exit(2)

    identity = '*'
    configfile = None
    possible_configfiles = ["/usr/local/etc/nodebot.conf", "/etc/nodebot.conf"]
    sendquit = False
    dodaemonize = True
    verbose = False
    singleShot = False
    for o, a in opts:
        if o in ('-h', '--help'):
            usage()
            sys.exit(0)
        elif o in ('-n', '--nodaemon'):
            dodaemonize = False
        elif o in ('-c', '--conf'):
            configfile = a
        elif o in ('-i', '--identity'):
            identity = a
        elif o in ('-q', '--quit'):
            sendquit = True
        elif o in ('-v', '--verbose'):
            verbose = True
        elif o in ('-s', '--single'):
            singleShot = True
        else:
            assert False, "unhandled option " + a

    if len(argv) < 2 and not sendquit:
        usage()
        sys.exit(2)

    if verbose:
        dodaemonize = False

    if not sendquit:
        arg_channel = argv[0]
        arg_msg = " ".join(argv[1:])

    defaults = {
        'idletime': 30,
        'listen_host': '127.0.0.1',
        'listen_port': 58113,
    }
    if configfile:
        possible_configfiles.insert(0, configfile)
        configfile = None
    for cf in possible_configfiles:
        if os.access(cf, os.R_OK):
            configfile = cf
    if not configfile:
        sys.stderr.write("Unable to find readable config files from " + string.join(possible_configfiles, ", ")+"\n")
        sys.exit(1)
        
    c = ConfigParser.RawConfigParser(defaults)
    c.read(configfile)

    if identity not in c.sections():
        if '*' not in c.sections():
            sys.stderr.write("Missing generic hostname identity [*] in config file, aborting\n")
            sys.exit(1)
        sys.stderr.write("Missing identity [" + identity + "] in config file, defaulting to [*] (hostname)\n")
        identity = '*'

    try:
        ircserver_host = c.get(identity, 'ircserver_host')
        ircserver_port = c.getint(identity, 'ircserver_port')
        ircserver_ssl = c.getboolean(identity, 'ircserver_ssl')
        ircserver_pass = c.get(identity, 'ircserver_pass')
    except ConfigParser.NoOptionError:
        sys.stderr.write("ircserver_host, ircserver_port and ircserver_ssl must all be specified in "+configfile+"\n")
        sys.exit(1)

    idletime = c.getint(identity, 'idletime')
    listen_host = c.get(identity, 'listen_host')
    listen_port = c.getint(identity, 'listen_port')

    me = os.uname()[1]
    if identity == '*':
        identity = me.split(".")[0]

    pendingoutput = {}
    registered = False

    preferred_nick = identity
    nick = preferred_nick



    readsockets = []
    writesockets = []
    upstreamdata = []


    mode = 'dependent'

    # determine if we should be the primary or the dependent
    listensock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listensock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        if not sendquit:
            listensock.bind( (listen_host, listen_port) )
            mode = 'primary'
    except socket.error:
        pass

    upstreamsock = None
    if mode == 'primary':
        # if we're the primary, then start listening for connections
        # from dependents
        listensock.listen(5)
        readsockets.append(listensock)
        
        # and connect to the irc server
        upstreamsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            upstreamsock.connect( (ircserver_host, ircserver_port) )
        except socket.error, e:
            sys.exit(1)

        if ircserver_ssl:
            upstreamsock = ssl.wrap_socket(upstreamsock)

        readsockets.append(upstreamsock)

    else: # dependent 
        upstreamsock = listensock
        # we're not going to use this socket to listen on, but rather to 
        # connect to the primary, so it is our upstream connection
        try:
            upstreamsock.connect( (listen_host, listen_port) )
        except socket.error:
            sys.exit(1)

    if sendquit:
        upstreamsock.send("-quit\n")
        upstreamsock.shutdown(socket.SHUT_RDWR)
        sys.exit(0)

    reading_stdin = False
    if arg_msg == '-':
        dodaemonize = False
        reading_stdin = True
        readsockets.append(sys.stdin)
    else:
        # close stdin ?
        for line in arg_msg.splitlines():
            upstreamdata.append( (arg_channel, line) )

    if mode == "primary":
        if ircserver_pass:
            queue_output(upstreamsock, "PASS " + ircserver_pass + "\r\n")
        queue_output(upstreamsock, "USER %s %s %s :%s\r\n" % (nick, "8", me, me))
        queue_output(upstreamsock, "NICK " + nick + "\r\n")

    running = True
    exitat = time.time() + idletime

    while True:
        try:
            if len(upstreamdata):
                if mode == 'primary':
                    if registered:
                        for chan, msg in upstreamdata:
                            m = "PRIVMSG #%s :%s\r\n" % (chan, msg)
                            queue_output(upstreamsock, m)
                        upstreamdata = []
                else:
                    for chan, msg in upstreamdata:
                        m = "#%s\t%s\n" % (chan, msg)
                        queue_output(upstreamsock, m)
                    upstreamdata = []
                    if not reading_stdin:
                        # when running in dependent mode and reading from
                        # stdin, we want to remain running until stdin
                        # is closed
                        running = False

            writesockets = [] 
            for g in pendingoutput:
                if len(pendingoutput[g]):
                    writesockets.append(g)
                    exitat = time.time() + idletime

            readready, writeready, exceptready = select.select(readsockets, writesockets, [], 10)

            if len(readready):
                if mode == "primary" and nick != preferred_nick:
                    queue_output(upstreamsock, "NICK " + preferred_nick + "\r\n", 0)
                for r in readready:
                    if r == listensock:
                        ifverbose("!! accepting new connection")
                        newsock, x = r.accept()
                        readsockets.append(newsock)
                    elif r == upstreamsock:
                        process_irccon(r)
                    elif r == sys.stdin:
                        ifverbose("processing stdin")
                        process_stdin(r)
                        ifverbose("processed stdin")
                    else:
                        process_dependent(r)

            if len(writeready):
                for w in writeready:
                    try:
                        line = pendingoutput[w].pop(0)
                        if len(pendingoutput[w]) == 0:
                            del pendingoutput[w]
                    except KeyError:
                        continue
                    ifverbose(">> %s" % (line.strip(),))
                    w.send(line)

            if time.time() > exitat:
                # FIXME idle time doesn't apply if we're reading from stdin
                ifverbose("!! idle time expired")
                raise TimeOut

        except (KeyboardInterrupt, TimeOut, select.error, socket.error):
            running = False
            if mode == "primary":
                if listensock:
                    readsockets.pop(readsockets.index(listensock))
                    listensock.shutdown(socket.SHUT_RDWR)
                    listensock = None

        if not pendingoutput:
            if not running:
                break

        #time.sleep(1)

    if mode == 'primary':
        ifverbose("!! disconnecting from upstream")
        upstreamsock.send("QUIT\r\n")
        upstreamsock.shutdown(socket.SHUT_RDWR)
        if listensock:
            listensock.shutdown(socket.SHUT_RDWR)


# vim: set expandtab:ai:ts=4
